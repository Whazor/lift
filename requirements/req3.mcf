% Wanneer een verdiepingsknop ingedrukt wordt,
% dan gaat de lift uiteindelijk naar deze verdieping mits het niet de huidige verdieping is.

% Na knop_verdieping(v) gebeurt dan moet er uiteindelijk een lift_benadert(v) en direct erna een vertraag actie; gevolgd door een verdieping_deur_open(v) en een lift_deur_open
% actie
%
% nu Y(sos: Bool=false).
%   [knop_trigger_sos]Y(!sos) &&
%   [!knop_trigger_sos]Y(sos) &&
%   (val(!sos) => forall v:Verdieping.
%     [knop_verdieping(v)] mu X.([!lift_benadert(v) && !knop_trigger_sos && !knop_deur_open]X && <!knop_trigger_sos && !knop_deur_open>true)
%   )

forall v:Verdieping .
  [knop_verdieping(v)] mu X . (
    [!lift_benadert(v)] X &&
    forall v2:Verdieping .
      nu Y . ([knop_verdieping(v2)]Y && [knop_trigger_sos]Y)
  )

% mu X.([!lift_benadert(v)]X && <true>true)
% this works, but lift_benadert doesn't neccessarily happens in an finite amount of steps since the sos and door openings can be
% performed indefinitely meaning there is a cycle

% the && are performed every recursion
% We recurse until [!lift_benadert] is empty, which happens when we get a lift_benadert, then the left hand is true, and the right must still be true


% mu Y.(<verdieping_deur_open(v)><lift_deur_open>true || <true>Y) || <true>X)
